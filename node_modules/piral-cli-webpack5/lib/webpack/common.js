"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRules = exports.getPlugins = exports.getVariables = exports.extensions = void 0;
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const utils_1 = require("piral-cli/utils");
const webpack_1 = require("webpack");
const SheetPlugin_1 = require("../plugins/SheetPlugin");
const piletCss = 'main.css';
function getStyleLoaders(production) {
    if (production) {
        return [MiniCssExtractPlugin.loader];
    }
    else {
        return [require.resolve('style-loader')];
    }
}
exports.extensions = ['.ts', '.tsx', '.js', '.jsx', '.json'];
function getVariables() {
    return Object.keys(process.env).reduce((prev, curr) => {
        prev[curr] = process.env[curr];
        return prev;
    }, {});
}
exports.getVariables = getVariables;
function getPlugins(plugins, production, pilet) {
    const otherPlugins = [
        new MiniCssExtractPlugin({
            filename: pilet ? piletCss : '[name].[fullhash:6].css',
            chunkFilename: '[id].[chunkhash:6].css',
        }),
    ];
    if (process.env.WEBPACK_PROGRESS) {
        otherPlugins.push(new webpack_1.ProgressPlugin((percent, msg) => {
            if (percent !== undefined) {
                (0, utils_1.progress)(`${~~(percent * 100)}% : ${msg}`);
                if (percent === 1) {
                    (0, utils_1.logReset)();
                    (0, utils_1.log)('generalInfo_0000', 'Bundling finished.');
                }
            }
        }));
    }
    if (production && pilet) {
        const name = process.env.BUILD_PCKG_NAME;
        otherPlugins.push(new SheetPlugin_1.default(piletCss, name, pilet));
    }
    return plugins.concat(otherPlugins);
}
exports.getPlugins = getPlugins;
function getRules(production) {
    const styleLoaders = getStyleLoaders(production);
    const nodeModules = /node_modules/;
    const babelLoader = {
        loader: require.resolve('babel-loader'),
        options: {
            presets: [require.resolve('@babel/preset-env'), require.resolve('@babel/preset-react')],
        },
    };
    const tsLoader = {
        loader: require.resolve('ts-loader'),
        options: {
            transpileOnly: true,
        },
    };
    return [
        {
            oneOf: [
                {
                    test: /\.s[ac]ss$/i,
                    use: [...styleLoaders, require.resolve('css-loader'), require.resolve('sass-loader')],
                },
                {
                    test: /\.css$/i,
                    use: [...styleLoaders, require.resolve('css-loader')],
                },
                {
                    test: /\.m?jsx?$/i,
                    use: [babelLoader],
                    exclude: nodeModules,
                },
                {
                    test: /\.tsx?$/i,
                    use: [babelLoader, tsLoader],
                },
                {
                    test: /\.codegen$/i,
                    use: [require.resolve('parcel-codegen-loader')],
                },
                {
                    test: /\.js$/i,
                    use: [require.resolve('source-map-loader')],
                    exclude: nodeModules,
                    enforce: 'pre',
                },
                {
                    // Exclude `js` files to keep "css" loader working as it injects
                    // its runtime that would otherwise be processed through "file" loader.
                    // Also exclude `html` and `json` extensions so they get processed
                    // by webpacks internal loaders.
                    exclude: [/^$/, /\.(js|mjs|jsx|ts|tsx)$/i, /\.html$/i, /\.json$/i],
                    type: 'asset/resource',
                },
                // Don't add new loaders here -> should be added before the last (catch-all) handler
            ],
        },
    ];
}
exports.getRules = getRules;
//# sourceMappingURL=common.js.map