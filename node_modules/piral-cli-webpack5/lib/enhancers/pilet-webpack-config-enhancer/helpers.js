"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withExternals = exports.withSetPath = exports.getDependencies = exports.getDefineVariables = exports.setEnvironment = exports.getVariables = void 0;
const path_1 = require("path");
function getVariables(name, version, env) {
    return {
        NODE_ENV: env,
        BUILD_TIME: new Date().toDateString(),
        BUILD_TIME_FULL: new Date().toISOString(),
        BUILD_PCKG_VERSION: version,
        BUILD_PCKG_NAME: name,
    };
}
exports.getVariables = getVariables;
function setEnvironment(variables) {
    Object.keys(variables).forEach((key) => (process.env[key] = variables[key]));
}
exports.setEnvironment = setEnvironment;
function getDefineVariables(variables) {
    return Object.entries(variables).reduce((obj, [name, value]) => {
        obj[`process.env.${name}`] = JSON.stringify(value);
        return obj;
    }, {});
}
exports.getDefineVariables = getDefineVariables;
function getDependencies(importmap, compilerOptions) {
    const dependencies = {};
    const { entry, externals } = compilerOptions;
    if (typeof entry === 'object' && entry && Array.isArray(externals) && typeof externals[0] === 'object') {
        for (const dep of importmap) {
            dependencies[dep.id] = dep.ref;
            externals[0][dep.name] = dep.requireId;
            if (dep.type === 'local') {
                entry[dep.ref.replace(/\.js$/, '')] = dep.entry;
            }
        }
    }
    return dependencies;
}
exports.getDependencies = getDependencies;
function withSetPath(compilerOptions) {
    if (typeof compilerOptions.entry === 'object' && compilerOptions.entry) {
        const setPath = (0, path_1.join)(__dirname, '..', '..', 'set-path');
        if (Array.isArray(compilerOptions.entry)) {
            compilerOptions.entry.unshift(setPath);
        }
        else {
            for (const key of Object.keys(compilerOptions.entry)) {
                const entry = compilerOptions.entry[key];
                if (Array.isArray(entry)) {
                    entry.unshift(setPath);
                }
            }
        }
    }
}
exports.withSetPath = withSetPath;
function withExternals(compilerOptions, externals) {
    const current = compilerOptions.externals || [];
    const arrayExternals = Array.isArray(current) ? current : [current];
    const objectExternal = externals.reduce((external, dep) => {
        external[dep] = dep;
        return external;
    }, {});
    const newExternals = arrayExternals.filter(external => {
        if (typeof external === 'object' && Object.keys(external).length) {
            for (const dep in external) {
                objectExternal[dep] = external[dep];
            }
            return false;
        }
        return true;
    });
    compilerOptions.externals = [objectExternal, ...newExternals];
}
exports.withExternals = withExternals;
//# sourceMappingURL=helpers.js.map