"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildConfiguration = exports.defaultConfig = exports.mergeConfiguration = exports.readConfiguration = exports.makePathsAbsolute = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const info_1 = require("../info");
const chalk = require("chalk");
function makePathsAbsolute(baseDir, config) {
    if (config) {
        if (config.directory) {
            config.directory = path_1.resolve(baseDir, config.directory);
        }
        if (config.client) {
            config.client = path_1.resolve(baseDir, config.client);
        }
        if (config.injectors) {
            for (const name of Object.keys(config.injectors)) {
                const injector = config.injectors[name];
                const directory = injector.directory;
                const localDir = injector.baseDir;
                if (typeof directory === 'string') {
                    injector.directory = path_1.resolve(baseDir, directory);
                }
                else if (Array.isArray(directory)) {
                    injector.directory = directory.map((dir) => path_1.resolve(baseDir, dir));
                }
                if (typeof localDir === 'string') {
                    injector.baseDir = path_1.resolve(baseDir, localDir);
                }
                else {
                    injector.baseDir = baseDir;
                }
            }
        }
        if (Array.isArray(config.middlewares)) {
            for (const middleware of config.middlewares) {
                const localDir = middleware.baseDir;
                if (typeof localDir === 'string') {
                    middleware.baseDir = path_1.resolve(baseDir, localDir);
                }
                else {
                    middleware.baseDir = baseDir;
                }
            }
        }
        if (Array.isArray(config.sources)) {
            config.sources = config.sources.map((dir) => path_1.resolve(baseDir, dir));
        }
    }
}
exports.makePathsAbsolute = makePathsAbsolute;
function readConfiguration(path) {
    if (path && fs_1.existsSync(path)) {
        const dir = path_1.dirname(path);
        try {
            const content = fs_1.readFileSync(path, 'utf8');
            const config = JSON.parse(content);
            if (config) {
                makePathsAbsolute(dir, config);
                return config;
            }
        }
        catch (e) {
            const msg = `Error reading configuration from "${path}" in "${dir}": ${e}`;
            throw new Error(`${chalk.red('ERR')} ${chalk.white(msg)}`);
        }
    }
    return {};
}
exports.readConfiguration = readConfiguration;
function deepMerge(obj, value) {
    Object.keys(value).forEach((key) => {
        const oldItem = obj[key];
        const newItem = value[key];
        if (newItem === undefined) {
            delete obj[key];
        }
        else if (Array.isArray(oldItem) && Array.isArray(newItem)) {
            obj[key] = [...oldItem, ...newItem];
        }
        else if (typeof oldItem === 'object') {
            obj[key] = deepMerge(Object.assign({}, oldItem), newItem);
        }
        else {
            obj[key] = newItem;
        }
    });
    return obj;
}
function mergeObjects(sources, select) {
    const obj = {};
    for (const source of sources) {
        const value = select(source);
        if (value && typeof value === 'object') {
            deepMerge(obj, value);
        }
    }
    return obj;
}
function mergeArrays(sources, select, compare) {
    const arr = [];
    for (const source of sources) {
        const value = select(source);
        if (value && Array.isArray(value)) {
            for (let i = arr.length; i--;) {
                const a = arr[i];
                for (const b of value) {
                    if (compare(a, b)) {
                        arr.splice(i, 1);
                    }
                }
            }
            arr.push(...value);
        }
    }
    return arr;
}
function mergeConfiguration(options = {}, ...configs) {
    const { initial = {}, required = {} } = options;
    const sources = [initial, ...configs, required];
    const result = Object.assign({}, ...sources);
    if (options.cert !== undefined || options.key !== undefined) {
        result.ssl = {
            cert: options.cert || (result.ssl && result.ssl.cert),
            key: options.key || (result.ssl && result.ssl.key),
        };
    }
    if (options.skipApi) {
        result.api = false;
    }
    if (options.logs) {
        result.logLevel = options.logs;
    }
    if (options.dir) {
        result.directory = options.dir;
    }
    if (options.name) {
        result.name = options.name;
    }
    if (options.port) {
        result.port = options.port;
    }
    if (options.host) {
        result.host = options.host;
    }
    result.injectors = mergeObjects(sources, (m) => m.injectors);
    result.map = mergeObjects(sources, (m) => m.map);
    result.sources = mergeArrays(sources, (m) => m.sources, (a, b) => a === b);
    result.injectorDirs = mergeArrays(sources, (m) => m.injectorDirs, (a, b) => a === b);
    result.middlewares = mergeArrays(sources, (m) => m.middlewares, (a, b) => a.source === b.source);
    return result;
}
exports.mergeConfiguration = mergeConfiguration;
const certDir = path_1.resolve(__dirname, '../../../cert');
exports.defaultConfig = {
    name: `${info_1.name} v${info_1.version}`,
    host: '0.0.0.0',
    port: 9000,
    directory: path_1.resolve(info_1.currentDir, 'mocks'),
    client: 'kras-management-portal',
    ssl: {
        cert: path_1.resolve(certDir, 'server.crt'),
        key: path_1.resolve(certDir, 'server.key'),
    },
    uploadLimit: parseInt(process.env.FILE_SIZE_LIMIT, 10) || 10,
    logLevel: 'error',
    api: '/manage',
    ws: true,
    map: {},
    auth: undefined,
    middlewares: [],
    injectorDirs: [],
    sources: [],
    injectors: {},
};
function buildConfiguration(config = {}) {
    const newConfig = Object.assign({}, exports.defaultConfig, config);
    const newMap = {};
    Object.keys(newConfig.map || {}).forEach((oldKey) => {
        const newKey = oldKey.replace(/\/+$/, '');
        newMap[newKey] = newConfig.map[oldKey];
    });
    newConfig.map = newMap;
    return newConfig;
}
exports.buildConfiguration = buildConfiguration;
