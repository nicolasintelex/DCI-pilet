"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const faker = require("faker");
const cookie = require("cookie");
const parser = require("accept-language-parser");
const faker_locale_1 = require("../helpers/faker-locale");
const generate_from_template_1 = require("../helpers/generate-from-template");
const helpers_1 = require("../helpers");
function find(response, randomize) {
    if (Array.isArray(response)) {
        const index = randomize ? Math.floor(Math.random() * response.length) : 0;
        return response[index];
    }
    return response;
}
class JsonInjector {
    constructor(options, config) {
        this.files = [];
        const directory = options.directory || config.sources || config.directory;
        this.config = options;
        this.watcher = helpers_1.watch(directory, '**/*.json', (ev, fileName, position) => {
            switch (ev) {
                case 'create':
                case 'update':
                    return this.load(fileName, position);
                case 'delete':
                    return this.unload(fileName);
            }
        });
    }
    getOptions() {
        return {
            randomize: {
                description: `If active randomizes the selected response. Only applicable in case where multiple responses are found for a given request.`,
                title: `Randomize Response`,
                type: 'checkbox',
                value: this.config.randomize || false,
            },
            directories: helpers_1.editDirectoryOption(this.watcher.directories),
            files: helpers_1.editEntryOption(this.files, ({ request }) => `${request.method} ${request.url}`),
        };
    }
    setOptions(options) {
        this.config.randomize = options.randomize;
        for (const { name, entries } of options.files) {
            const files = this.files.find((m) => m[0].file === name);
            if (entries) {
                for (let i = 0; i < entries.length; i++) {
                    const entry = entries[i];
                    const file = files[i];
                    if (file && typeof entry.active === 'boolean') {
                        file.active = entry.active;
                    }
                }
            }
        }
        this.watcher.directories = options.directories;
    }
    get name() {
        return 'json-injector';
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    unload(fileName) {
        const index = this.files.findIndex((m) => m[0].file === fileName);
        if (index !== -1) {
            this.files.splice(index, 1);
        }
    }
    load(fileName, position) {
        const content = helpers_1.asJson(fileName);
        const items = Array.isArray(content) ? content : [content];
        for (const item of items) {
            item.file = fileName;
            item.active = true;
            if (typeof item.request !== 'object') {
                item.request = {};
            }
            if (typeof item.response !== 'object') {
                item.response = {};
            }
        }
        this.unload(fileName);
        if (items.length > 0) {
            this.files.splice(position, 0, items);
        }
    }
    dispose() {
        this.watcher.close();
    }
    contentProcess(req, content) {
        if (this.config.generator) {
            const localeName = this.config.generatorLocaleName || 'language';
            const cookies = cookie.parse(req.headers.cookie || '');
            const acceptLanguage = parser.parse(req.headers['accept-language']);
            let locale = 'en';
            if (req.query[localeName]) {
                locale = req.query[localeName];
            }
            else if (cookies[localeName]) {
                locale = cookies[localeName];
            }
            else if (acceptLanguage.length && acceptLanguage[0].code) {
                locale = acceptLanguage[0].code;
            }
            // Convert like: en, en-US to en_US
            faker.setLocale(faker_locale_1.default(locale) || locale);
            // Ignore Buffer content
            if (Buffer.isBuffer(content))
                return content;
            if (typeof content === 'string') {
                content = JSON.parse(content);
            }
            const templateJson = generate_from_template_1.generateFromTemplate(content);
            return JSON.stringify(templateJson);
        }
        return content;
    }
    handle(req) {
        let i = 0;
        for (const files of this.files) {
            for (const { file, active, request, response } of files) {
                if (active) {
                    if (helpers_1.compareRequests(request, req)) {
                        const rand = this.config.randomize;
                        const res = find(response, rand);
                        const name = this.name;
                        const content = this.contentProcess(req, res.content);
                        return helpers_1.fromJson(request.url, res.status.code, res.status.text, res.headers, content, {
                            name,
                            file: {
                                name: file,
                                entry: i,
                            },
                        });
                    }
                }
                i++;
            }
        }
    }
}
exports.default = JsonInjector;
